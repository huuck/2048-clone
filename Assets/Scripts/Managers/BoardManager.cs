//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18063
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;

public class BoardManager : Singleton<BoardManager> {
	private List<VOTile> 	tiles;

	public 	int 			NumRows = 4;
	public 	int 			NumColumns = 4;

	public 	float 			ChanceToSpawnJoker 	= 0.05f;
	public  float			ChanceToSpawnTwo 	= 0.5f;
	public  float			ChanceToSpawnThree 	= 0.1f;
	private int[] 			spawnPool;

	protected BoardManager () {
	}

	public void Init() {
		tiles = new List<VOTile> ();
		spawnPool = new int[3];
	}

	public int CalculateScore() {
		int ret = 0;
		int i;

		for(i = 0; i < tiles.Count; i++) {
			ret += tiles[i].value;
		}

		return ret;
	}

	//spawns a specific number of tiles (and returns them to the board behaviour script)
	public List<VOTile> SpawnTiles(int numTilesToAdd) {
		List<VOTile> ret = new List<VOTile> ();

		int i;
		int randomRow;
		int randomColumn;
		int randomTilePoolIndex;
		for(i = 0; i < numTilesToAdd && tiles.Count < NumRows * NumColumns; i++) {
			do {
				randomRow = Mathf.FloorToInt(UnityEngine.Random.Range(0, NumRows));
				randomColumn = Mathf.FloorToInt(UnityEngine.Random.Range(0, NumColumns));
			}while(getTileAt(randomRow, randomColumn) != null);

			randomTilePoolIndex = 1;

			if(UnityEngine.Random.value < ChanceToSpawnTwo) {
				randomTilePoolIndex = 2;
			}

			if(UnityEngine.Random.value < ChanceToSpawnThree) {
				randomTilePoolIndex = 3;
			}

			var newTile = new VOTile(randomRow, randomColumn, randomTilePoolIndex);

			//chance to get a joker
			if(UnityEngine.Random.value < ChanceToSpawnJoker) {
				newTile.value = -1;
			}

			tiles.Add(newTile);
			ret.Add(newTile);
		}

		return ret;
	}

	public bool AreMovesAvailable() {
		VOTile adjacentTile;

		if(tiles.Count < NumRows * NumColumns) {
			return true;
		}


		int i;
		for(i = 0; i < tiles.Count; i++) {
			//looks down and to the left for any more moves
			adjacentTile = getTileAt(tiles[i].row + 1, tiles[i].column);
			if(adjacentTile != null) {
				if(tilesCanMerge(tiles[i], adjacentTile) == true) {
					return true;
				}
			}

			adjacentTile = getTileAt(tiles[i].row, tiles[i].column + 1);
			if(adjacentTile != null) {
				if(tilesCanMerge(tiles[i], adjacentTile) == true) {
					return true;
				}
			}
		}

		return false;
	}

	private bool tilesCanMerge(VOTile tile1, VOTile tile2) {
		if(	(tile1.value == tile2.value  && (tile2.value >= 3 && tile1.value  >= 3)) || 
		  	(tile1.value != tile2.value  &&  (tile2.value  < 3 && tile1.value  < 3)) ||
		    (tile1.value < 0) || (tile2.value < 0))
		{
			return true;
		}

		return false;
	}

	public void MoveTiles(int moveDirection) {
		int rowSpeed = 0;
		int columnSpeed = 0;

		switch (moveDirection) {
			case (int)SwipeDirection.LEFT: 		rowSpeed = 0; 	columnSpeed = -1; 	break;
			case (int)SwipeDirection.RIGHT: 	rowSpeed = 0; 	columnSpeed = 1;	break;
			case (int)SwipeDirection.UP: 		rowSpeed = 1; 	columnSpeed = 0; 	break;
			case (int)SwipeDirection.DOWN: 		rowSpeed = -1; 	columnSpeed = 0; 	break;
		}


		int i;
		VOTile overlappingTile;

		List<VOTile> movedTiles = new List<VOTile>();

		//Good riddance that we have so much processing power and we can write simple algorithms.
		//The more optimised implementation whould have needed a matrix that would be traversed in different ways (column/row wise from one side to the other)
		while (movedTiles.Count < tiles.Count) {
			for(i = 0; i < tiles.Count; i++) {
				if(movedTiles.IndexOf(tiles[i]) == -1) {
					if(isMoveEligible(tiles[i], rowSpeed, columnSpeed) == true) {
						overlappingTile = getTileAt(tiles[i].row + rowSpeed, tiles[i].column + columnSpeed);
						
						if(overlappingTile == null) {
							tiles[i].row += rowSpeed;
							tiles[i].column += columnSpeed;
							tiles[i].state = VOTile.STATE_MOVING;
							movedTiles.Add(tiles[i]);
						} else if(tilesCanMerge(tiles[i], overlappingTile) && movedTiles.IndexOf(overlappingTile) > -1) {
							tiles[i].row += rowSpeed;
							tiles[i].column += columnSpeed;

							tiles[i].value = Math.Max(tiles[i].value, overlappingTile.value) * 2;
							if(tiles[i].value == 4) tiles[i].value = 3;
							movedTiles.Add(tiles[i]);
							tiles.Remove(overlappingTile);
							overlappingTile.state = VOTile.STATE_DIE;
						} else if(movedTiles.IndexOf(overlappingTile) > -1){
							movedTiles.Add(tiles[i]);
						}
					} else {
						movedTiles.Add(tiles[i]);
					}
				}
			}
		}
	}
	
	private bool isMoveEligible(VOTile tileToMove, int rowSpeed, int columnSpeed) {
		bool ret = 	(tileToMove.row 	+ rowSpeed 		< 	NumRows) 	&&
					(tileToMove.row 	+ rowSpeed 		>= 	0) 			&&
					(tileToMove.column 	+ columnSpeed	< 	NumColumns) &&
					(tileToMove.column 	+ columnSpeed	>= 	0);

		return	ret;
	}

	private VOTile getTileAt(int row, int column) {
		int i;
		for(i = 0; i < tiles.Count; i++) {
			if(tiles[i].row == row && tiles[i].column == column) {
				return tiles[i];
			}
		}

		return null;
	}

	public bool IsBoardAnimating() {
		int i;
		for(i = 0; i < tiles.Count; i++) {
			if(tiles[i].state != VOTile.STATE_IDLE) {
				return true;
			}
		}

		return false;
	}
}

